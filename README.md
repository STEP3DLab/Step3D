Техническое задание на проект «Step3D». Калькулятор печати»
Общее описание проекта
«Step3D». Калькулятор печати» – это веб-приложение (HTML5) для загрузки и интерактивного просмотра 3D-моделей в форматах STL и OBJ на светлом фоне с минималистичным дизайном. Приложение позволяет пользователю без сложных настроек загрузить свою 3D-модель и сразу же увидеть ее визуализацию в браузере. Одновременно сервис автоматически рассчитывает предварительную стоимость 3D-печати загруженной модели на основе стандартных параметров (тип материала – PLA или ABS, плотность материала, ориентировочное время печати, объем модели и т.д.), без ввода технических параметров со стороны пользователя – от пользователя требуется лишь указать желаемые габариты печати (размер модели). Результатом использования приложения является отображение 3D-модели с возможностью вращения/масштабирования и вывод предварительной оценки стоимости печати этой модели.
Приложение Step3D ориентировано на широкий круг пользователей: от любителей 3D-печати, желающих быстро оценить стоимость изготовления своей модели, до специалистов сервисов печати, которым нужен инструмент для оперативной оценки заказов. За счет применения современных веб-технологий (WebGL/Three.js) и оптимизированного кода, Step3D будет работать в любом современном браузере на настольных компьютерах и мобильных устройствах. Проект должен быть разработан с учетом передовых практик в области веб-разработки и UI/UX-дизайна (современный минималистичный интерфейс, высокая производительность, адаптивность интерфейса), а исходный код – подготовлен для открытого размещения на GitHub. В дальнейшем планируется расширение функциональности, включая интеграцию с Google Sheets/Google Apps Script для хранения результатов расчетов и подключение платежных систем или сервисов онлайн-заказа 3D-печати.
Цели и задачи проекта
Основная цель проекта – создать удобное и простое средство визуализации 3D-моделей с мгновенным расчётом стоимости 3D-печати, не требующее от пользователя специальных знаний. Для достижения этой цели должны быть решены следующие задачи:
Реализовать надёжную функцию загрузки 3D-файлов (STL, OBJ) через браузер, включая обработку ошибок (неверный формат, слишком большой файл и пр.).


Обеспечить корректное отображение 3D-модели в окне браузера с возможностью пользователю вращать, масштабировать модель и просматривать её со всех сторон.


Разработать алгоритм автоматического расчёта стоимости печати по стандартной формуле, учитывающей объём модели, материал, плотность заполнения, ориентировочное время печати и другие параметры, при этом требуя от пользователя только ввода габаритов (масштаба) модели и выбора материала.


Создать интуитивно понятный пользовательский интерфейс: минимальное число элементов управления, отсутствие визуального «шума», светлая цветовая схема, акцент на самой модели и результате расчёта.


Обеспечить кросс-браузерную и кросс-платформенную работу приложения – поддержка всех современных браузеров (Chrome, Firefox, Safari, Edge и др.) и корректная работа на настольных ПК, планшетах и смартфонах.


Использовать современный технологический стек (JavaScript/ES6, библиотека Three.js для 3D, HTML5, CSS3 и пр.), следуя лучшим практикам разработки (структурированный, читаемый код, разделение логики и представления, адаптивная верстка).


Подготовить проект к открытой публикации: предоставить инструкции по развёртыванию и размещению на GitHub (например, через GitHub Pages), учесть требования лицензирования (при необходимости) и возможности совместной разработки.


Заложить основу для будущих расширений: интеграция с Google Sheets (для хранения параметров расчета или результатов) и подключение платёжных систем/сервисов печати (для непосредственного заказа пользователем печати по рассчитанной стоимости).


Функциональные требования
Загрузка 3D-моделей
Поддерживаемые форматы: Пользователь должен иметь возможность загрузить файл 3D-модели в формате STL (стандартный формат стереолитографии, широко применяемый в 3D-печати) или OBJ (текстовый формат описания 3D-геометрии). В перспективе архитектура приложения должна позволять легко добавлять поддержку новых популярных форматов (например, GLTF/GLB, FBX, PLY и др.).


Способы загрузки: Предусмотреть поле для выбора файла (input type="file") и поддержку Drag & Drop – пользователь должен мочь перетащить файл модели прямо в окно приложения для загрузки. После выбора/перетаскивания файла начинается процесс его обработки.


Ограничения на файлы: Приложение должно обрабатывать файлы разумного размера. Рекомендуется ограничить максимальный размер загружаемого файла (например, ~20-50 МБ) и показывать понятное сообщение об ошибке, если файл слишком велик или имеет неподдерживаемый формат. Также следует обработать сценарий загрузки некорректного/поврежденного файла – отобразить ошибку «Не удалось загрузить модель. Проверьте формат файла.».


Парсинг и подготовка модели: После получения файла, фронтенд-приложение с помощью соответствующей библиотеки (см. Стек технологий ниже) должно распознать формат (STL или OBJ) и прочитать геометрию модели. Необходимо вычислить основные свойства модели: габаритные размеры (длина, ширина, высота), объем модели (если модель является замкнутым твердым объектом) и площадь поверхности (при необходимости). Эти величины будут использоваться при расчете стоимости. Примечание: Формат STL содержит описание поверхности (треугольные грани), из которого можно вычислить объем замкнутого объекта. Для OBJ объем вычисляется при условии наличия замкнутой геометрии (OBJ может содержать открытые меши, тогда расчет объема может быть неточным).


Нормализация масштаба: Если единицы измерения в загруженном файле не заданы явно, считать размеры модели заданными в миллиметрах (стандарт для STL из CAD-приложений) или предоставить пользователю возможность выбора/уточнения масштаба. Пользователь должен иметь возможность ввести масштабный коэффициент или задать желаемый размер модели (например, высоту или длину в мм), по которому приложение пропорционально масштабирует модель до требуемых габаритов. Это единственный «технический» ввод со стороны пользователя – указание физических размеров модели, необходимых для реального расчета расхода материала.


Обработка нескольких объектов: Если загруженный файл содержит несколько объектов/мешей (например, несколько отдельных деталей в одном OBJ), на первом этапе достаточно отображать их вместе как единую сцenu. В ТЗ можно указать, что поддержка множества моделей в одном файле – опциональна; при реализации первой версии можно ограничиться одним объектом в файле. Если же файл содержит несколько частей, можно предупреждать пользователя или автоматически применять расчет стоимости ко всем суммарно.


Отображение и взаимодействие с 3D-моделью
3D-рендеринг: Приложение должно визуализировать загруженную модель в режиме реального времени с использованием WebGL. Необходимо создать трехмерную сцену, добавить камеру и источник света, и отобразить геометрию модели. Рекомендуется использовать библиотеку Three.js как высокоуровневый инструмент для работы с WebGL-графикой (Three.js предоставляет готовые загрузчики форматов STL/OBJ, камеры, освещение и пр.).


Вид по умолчанию: После загрузки модель должна быть автоматически отцентрирована в сцене и вписана в видимую область. Камера по умолчанию устанавливается так, чтобы вся модель была видна целиком (например, камера направлена на центр модели, расстояние определяется по размеру bounding box модели).


Фон и окружение: Фон сцены – светлый однородный (например, белый или светло-серый) в соответствии с минималистичным стилем. Отражения или сложная окружающая среда не требуются; достаточно мягкого освещения, чтобы модель была различима. Можно использовать однотонный фон без сетки/осей, либо опционально предоставить переключатель «показать/скрыть оси координат» для продвинутых пользователей.


Управление камерой: Пользовательский интерфейс просмотра должен позволять вращать модель, масштабировать и панорамировать вид:


Вращение (orbit) – при зажатии левой кнопки мыши и перемещении (или касании и драге на сенсорном экране) модель поворачивается вокруг центра. Использовать контроллер OrbitControls из Three.js или аналогичный.


Масштабирование (zoom) – с помощью колесика мыши (scroll) или жеста pinch (сведение/разведение двух пальцев) на тачскрине. Диапазон масштабирования ограничить, чтобы модель не ушла вне видимости или не проникла «внутрь» камеры.


Панорамирование (pan) – при зажатии правой кнопки мыши (или специальной комбинации, напр. Shift + левая кнопка) пользователь может смещать вид по горизонтали/вертикали, если модель приближена.


Эти функции управления должны работать плавно как на компьютере (мышь), так и на мобильных устройствах (сенсорные жесты). Следует учесть инерцию вращения/зуммирования (по желанию) и ограничения углов (например, ограничить вращение по вертикали, чтобы камера не переворачивалась под сцену).


Отображение модели: Модель отображается в однотонном цвете (например, нейтральный серый) либо с простым материалом (Lambert/Phong с мягким освещением) – сложные текстуры или цвета из файла OBJ можно игнорировать для упрощения визуального стиля. Цель – чётко показать форму модели. Факультативно можно реализовать переключение режима отображения: солид (залитый) / каркас (wireframe) / прозрачность, однако в минималистичном первом варианте достаточно залитого режима. Если модель очень большая или сложная, возможно, стоит предусмотреть упрощение меша (LOD) или выдавать предупреждение.


Свет и тени: Для минималистичного стиля достаточно одного источника света (например, направленного света сверху-сбоку) и мягкого освещения ambient. Тени можно отключить (или включить простое отображение тени модели на «плоскости» для визуального эффекта опоры). Главное – модель должна быть хорошо различима на светлом фоне, с мягкими градациями освещения. Не следует использовать резкие/кислотные цвета фона или подсветки, избегать перегруженности эффектами.


Анимация/автоповорот: В базовой версии автоповорот модели (360° вращение) не обязателен, но можно добавить опцию «Автовращение», при включении которой модель медленно вращается, позволяя рассмотреть ее со всех сторон без участия пользователя. Эта опция должна быть выключена по умолчанию (чтобы не отвлекать пользователя лишним движением).


Обработка ошибок при рендеринге: Если при попытке отобразить модель произошла ошибка (например, модель не загрузилась, или файл содержит неподходящие данные), интерфейс должен отобразить сообщение об ошибке. Пользователю должно быть предложено попробовать снова с другим файлом или проверить корректность файла.


Автоматический расчет стоимости 3D-печати
Одной из ключевых функций Step3D является мгновенный расчет стоимости 3D-печати по загруженной модели. Этот расчет должен выполняться автоматически сразу после загрузки модели (и указания пользователем требуемых габаритов/масштаба) – без необходимости вводить вручную технические параметры печати. Ниже описана логика и формулы расчета:
Параметры для расчета: Стоимость печати будет зависеть от следующих величин:


Объем модели (V) – вычисляется из загруженной 3D-геометрии. Выражается в кубических сантиметрах (см³). Это объем материала, который займет сплошная модель указанных габаритов.


Тип материала – пользователь выбирает из двух опций: PLA или ABS (пластики для FDM-печати). От материала зависят плотность и стоимость сырья.


Плотность материала (ρ) – удельный вес пластика. Для расчетов можно заложить: PLA ~ 1.24 г/см³, ABS ~ 1.04 г/см³ (эти значения могут быть настроены в конфигурации).


Индекс заполнения – доля объема, которая будет заполнена материалом при печати. Обычно при 3D-печати модели печатаются не полностью залитыми, а с некоторым процентом заполнения (инфилом), например 20%. В стандартном расчете можно взять инфил 20% для PLA и ABS по умолчанию. Это означает, что реальный объем использованного материала будет 0.2 * V (если модель печатается с внутренней решеткой 20% плотности). Примечание: Для простоты можно на первом этапе считать инфил фиксированным (20%), либо позволить пользователю выбрать из нескольких уровней (например, 20%, 50%, 100% заполнение) – однако это уже технический параметр, от которого в ТЗ решили отказаться. Поэтому лучше фиксировать некий усредненный процент заполнения (например, 20%) без ручного ввода.


Вес модели (m) – вычисляется на основе объема и плотности с учетом заполнения: m = V * ρ * инфил. Например, если объем модели 100 см³, материал PLA (1.24 г/см³) и инфил 20%, то масса пластика ≈ 100 * 1.24 * 0.2 = 24.8 г.


Стоимость материала за единицу массы – устанавливается на основе рыночной цены пластика. Например, если 1 кг PLA стоит 2000 ₽, то 1 грамм ~ 2 ₽. Эти данные могут быть заложены как константы или подтягиваться из конфигурации/Google Sheets. Для ТЗ достаточно указать, что цена материала задается как параметр, например PLA: 1500–2000 ₽/кг, ABS: 1200–1800 ₽/кг (точные значения определяются при внедрении и могут редактироваться).


Оценка времени печати (t) – приблизительное время, необходимое для печати модели указанного объема. Время зависит от объема, а также от настроек принтера (скорость печати, высота слоя). Так как пользователь не вводит эти параметры, следует принять усредненную скорость печати. Например, рассчитать, что FDM-принтер печатает X кубических сантиметров в час. По опыту, при слое 0.2 мм и средней скорости ~50 мм/с, объемная скорость может быть ~ 10–20 см³/час. Для простоты можно взять константу, например: 10 см³/час для PLA и ABS. Тогда время печати t (часы) = V * (инфил) / 10 см³/час. В примере с V=100 см³ и инфил=0.2: t = (100*0.2)/10 = 2 часа. (Эта модель дает грубую оценку; в реальности время сильно зависит от геометрии, но в рамках предварительного расчета этого достаточно.)


Ставка стоимости печати в час – условная стоимость использования 3D-принтера за час (включая амортизацию оборудования, электроэнергию, труд оператора). Например, можно заложить ставку X ₽/час (условно 100–300 ₽/час, зависит от локальных условий). Эту ставку также сделать настраиваемой. Она отражает «трудовую» составляющую цены.


Наценка/маржа – дополнительный процент, покрывающий непредвиденные расходы или обеспечивающий прибыль. На начальном этапе можно не применять наценку, либо заложить небольшой процент (например, 10–20%). Маржа будет добавляться к себестоимости материала и времени.


Формулы расчета:


Материальные затраты = масса модели (m, в граммах) * стоимость материала за 1 грамм. Альтернативно, можно рассчитать через объем: объем * плотность * (стоимость за 1 кг / 1000). По сути, этот расчет прямо отражает цену пластика, израсходованного на модель. Например, материал PLA: m грамм * 2 ₽/г. Формула соответствует принципу: material cost = (цена за 1 кг / 1000) × m (в г).


Трудозатраты (печать) = время печати (t, в часах) * ставка ₽/час. Это учитывает износ принтера, затраченное время оператора и пр. (Напр., t=2 ч * 200 ₽/ч = 400 ₽).


Базовая стоимость = материальные затраты + трудозатраты. Это пока что себестоимость без прибыли.


Наценка/маржа = определенный процент от базовой стоимости, например 20%. (Опционально, может быть настроено.)


Итоговая предварительная цена = базовая стоимость + маржа (или = базовая стоимость * (1 + маржа%)). По сути: final price = (material + labor) × (1 + markup).


Вывод результата: Приложение должно показать рассчитанные значения пользователю. Минимально – итоговую стоимость печати (в выбранной валюте, например, ₽) крупно и заметно. Дополнительно имеет смысл вывести подробности, чтобы пользователь понял из чего складывается цена:


Объем модели (см³);


Оценочное время печати (часы/минуты);


Вес пластика (грамм) и выбранный материал;


Стоимость материала для этого веса;


Стоимость работы (по времени);


(Если применена маржа) величину наценки;


Однако, учитывая минимализм интерфейса, полный расклад можно показывать по желанию пользователя (например, по нажатию «Подробнее…»). По умолчанию можно отобразить лишь общую стоимость и, возможно, один-два ключевых параметра (к примеру: "~24.8 г PLA, ~2 ч печати"). Цифры должны сопровождаться понятными единицами измерения.


Обновление расчета при изменениях: Если пользователь меняет какие-то параметры, которые доступны для изменения (например, выбрал другой материал или указал другой масштаб/размер модели), расчет должен пересчитываться динамически. Т.е. при изменении материала с PLA на ABS сразу пересчитать плотность, массу и стоимость и обновить вывод. Желательно реализовать это без перезагрузки страницы – прямо в браузере (JavaScript вычисляет по формулам).


Интеграция с Google Sheets (опционально): Закладка на будущее – расчетная формула и параметры могут храниться в Google Sheet для удобства обновления. Например, таблица может содержать: материал, плотность, цена за кг, ставка часа, маржа и др. Приложение могло бы через Google Apps Script API получать эти параметры. Но даже если в первой версии значения зашиты в коде, архитектурно нужно предусмотреть, чтобы их можно было легко изменить (в одном месте) или загрузить из внешнего источника без переписывания приложения.


Примечание: В типичном калькуляторе цены 3D-печати полная стоимость обычно состоит из стоимости материалов (прямо пропорциональной объему и цене пластика) и стоимости работы (времени печати), на которые затем может накладываться наценка для прибыли. В нашем приложении мы используем аналогичный принцип автоматического расчета без детализации для пользователя всех технических параметров.
Пользовательский интерфейс и архитектура страницы
Интерфейс Step3D должен быть простым, интуитивно понятным и минималистичным, чтобы пользователь сосредоточился на модели и результате. Страница приложения представляет собой одностраничный интерфейс (single-page app), состоящий из следующих основных областей:
Шапка (header) – в минималистичном дизайне может отсутствовать вовсе или содержать лишь название проекта Step3D и короткое описание/слоган. Можно расположить логотип или название в углу. Шапка должна занимать минимум места.


Основная область просмотра – занимает большую часть экрана. Здесь располагается окно рендера 3D-модели (canvas WebGL). Этому блоку следует отвести максимальную площадь, чтобы модель отображалась крупно. Соотношение сторон canvas – адаптивное (например, 16:9 или заполняет доступное пространство). Фон – светлый (белый).


Панель информации/управления – элементы UI, необходимые для взаимодействия. В идеале, минимальное перекрытие области модели. Возможные варианты размещения:


Вариант 1: Боковая панель справа (или слева) от 3D-вида. На ней выводится рассчитанная стоимость и параметры, а также кнопки (например, «Загрузить другую модель», «Выбрать материал», поля ввода размеров). Ширина панели — минимально достаточная (например, 300px), чтобы не отнимать лишнюю область у 3D-вида. При адаптации на мобильных устройствах эта панель может перемещаться вниз под областью модели или сворачиваться в выпадающее меню.


Вариант 2: Нижняя панель/подвал под 3D-видом. Содержит те же элементы – стоимость, настройки. На десктопе может отображаться горизонтальной полосой, а на мобильном – занимать всю ширину снизу, возможно, со скроллом, если не помещается.


Кнопка/поле загрузки – в начальном состоянии (когда ни одной модели не загружено) центральная область может показывать приглашение: «Загрузите STL или OBJ файл сюда» (с указанием, что можно перетащить файл мышью). Это может быть реализовано как пунктирная область или просто текст-инструкция. После загрузки эта подсказка исчезает (заменяется на 3D-вид).


Выбор материала – элемент управления, позволяющий пользователю указать тип пластика: радиокнопки или выпадающий список с опциями PLA / ABS. Расположить его можно на панели управления. Например, подпись "Материал:" и два радиокнопки. По умолчанию выбрано PLA.


Ввод габаритов/масштаба – поле, где пользователь может указать желаемый размер модели. Возможно, лучше спрашивать длину большей стороны модели в миллиметрах (и масштабировать пропорционально). Например: "Укажите желаемый размер (длина или высота) модели, мм". После ввода этого значения и подтверждения, модель рескейлится. Альтернативно, можно позволить ввод масштабного коэффициента (% или X:Y:Z), но это сложнее для понимания. В минимальном варианте – одно число (размер), автоматически применяемое к максимальному измерению модели, сохраняется пропорция. Это поле может быть заранее заполнено текущим размером из файла (например, если STL уже в мм, можно показать его высоту и позволить изменить).


Отображение результатов расчета – как отмечалось, отобразить основную информацию: рассчитанную стоимость. Например: "Стоимость: 530 ₽". Можно подчеркнуть, что это предварительно: мелким шрифтом "предварительная оценка". Рядом или ниже – ссылка/кнопка "Детали расчета", раскрывающая блок с подробными данными (объем, время, вес и т.д.). Если место позволяет, на десктопе можно сразу показать основные детали.


Дополнительные кнопки:


"Загрузить модель" (повторно) – чтобы пользователь мог заменить модель новой, не перезагружая страницу. При нажатии открывается диалог выбора файла. Эта же функция может быть реализована через перетаскивание: если пользователь перетащит новый файл – заменяем старую модель на новую.


(Опционально) "Сохранить расчет" или "Экспорт" – если интеграция с Google Sheets реализована, кнопка для сохранения результата (отправки данных в таблицу) или скачивания отчета (PDF/скриншот).


(В перспективе) "Заказать печать" – кнопка, которая может появиться при интеграции с платежной системой, позволяющая перейти к оформлению заказа печати данной детали.


Сообщения и ошибки – где-то в интерфейсе (например, всплывающее уведомление или выделенная область) должны выводиться подсказки и ошибки: "Файл загружается...", "Ошибка: неподдерживаемый формат" и т.п. После успешной загрузки можно на короткое время показывать "Модель загружена, выполняется расчет...".


Архитектура страницы должна быть адаптивной: т.е. при изменении размера окна или на мобильном устройстве, блоки выстраиваются вертикально. Например, на телефоне сначала будет видна область модели (возможно, уменьшенная высота, например, квадрат 300x300px), ниже – панель информации (материал, размер, цена). Элементы интерфейса (кнопки, текст) должны быть достаточно крупными для тач-управления на экране смартфона.
Пример возможного интерфейса представлен ниже. Справа отображается загруженная 3D-модель, слева – панель с выбранным материалом, рассчитанным временем, весом и стоимостью печати.
Пример интерфейса приложения для просмотра 3D-модели и расчета стоимости печати. Основная часть отведена под окно 3D-визуализации модели; сбоку показан расчёт (время печати, масса и итоговая цена). В Step3D планируется аналогичный минималистичный подход к расположению элементов.
Технологический стек
Для реализации приложения Step3D предлагается следующий технологический стек и инструменты:
HTML5 и CSS3: Разметка страницы и стили оформления. Использовать семантически правильную структуру (основной контейнер, секция просмотра, панель управления и т.д.). CSS – для создания адаптивного макета (flexbox или grid для компоновки боковой панели и основного окна). Предусмотреть медиазапросы для разных экранов (например, одна колонка на мобильных).


JavaScript (ES6+): Основная логика приложения – загрузка файлов, работа с 3D-библиотекой, расчет стоимости – реализуется на чистом JS. Можно использовать модульный подход (ES6 modules) или собрать скрипты с помощью сборщика (Webpack, Parcel и т.п.) для удобства. Код должен быть структурирован по функциональным частям: например, viewer.js (инициализация 3D сцены, отрисовка модели), calculator.js (расчет стоимости), ui.js (обработка событий интерфейса).


Three.js: Популярная библиотека для 3D-графики в браузере. Она значительно упростит работу с WebGL. В проекте Three.js будет использоваться для:


Загрузки моделей: класс THREE.STLLoader для STL и THREE.OBJLoader для OBJ (а при расширении форматов – соответствующие загрузчики GLTFLoader, etc.).


Создания сцены, камеры (THREE.PerspectiveCamera), рендера (THREE.WebGLRenderer).


Настройки материалов и освещения (например, THREE.MeshStandardMaterial или THREE.MeshLambertMaterial для простого освещения модели).


Контроллер орбитального управления камерой (OrbitControls) – хотя он не входит в core Three.js, но поставляется как add-on.


Three.js хорошо поддерживает современные браузеры и устройства, предоставляя единый API для WebGL2/WebGL1. Кроме того, благодаря Three.js, приложение сможет легко поддержать больше форматов 3D-файлов в будущем (например, тот же GLTF/GLB).


WebGL: Низкоуровневая технология, лежащая в основе Three.js. Напрямую писать шейдеры и WebGL-код не потребуется (Three.js абстрагирует), но нужно помнить, что производительность приложения будет зависеть от возможностей графического ускорителя клиента. WebGL поддерживается всеми современными браузерами (Chrome, Firefox, Safari, Edge) на ПК и мобильных, за исключением очень старых устройств. Нужно включить проверку: если WebGL недоступен, выводить сообщение типа "Ваш браузер не поддерживает WebGL. Обновите браузер или устройство." (Three.js предоставляет скрипт WebGL.js для проверки поддержки).


File API: В браузере для обработки загруженных файлов. Например, использование FileReader для чтения содержимого STL/OBJ файлов в двоичном или текстовом формате, далее передача этих данных в загрузчик Three.js. (Three.js loaders умеют работать либо с URLs, либо с загруженными ArrayBuffer, поэтому интеграция через FileReader -> Loader.parse).


Дополнительные библиотеки: По возможности, избегать тяжелых фреймворков, чтобы сохранить быстродействие и «легкость» приложения. Например, нет необходимости подключать jQuery или большие UI-библиотеки. Если нужен какой-то UI-компонент (скажем, слайдер или выпадающее меню), можно реализовать его вручную или использовать легковесные npm-пакеты.


CSS-фреймворк (опционально): При минималистичном дизайне можно обойтись без Bootstrap/Foundation, т.к. дизайн специфичен. Однако можно воспользоваться, например, Milligram или Bulma – современные легкие CSS-фреймворки, которые дадут базовые стили формы, кнопок, сетки, не перегружая дизайн. Это необязательное решение – можно также стилизовать всё с нуля, чтобы максимально точно соответствовать требованиям UI/UX.


Google Apps Script / Sheets API (в перспективе): Если потребуется интеграция с Google Sheets, можно использовать JavaScript Fetch API для отправки HTTP-запросов к веб-приложению Apps Script. Например, Apps Script может быть развернут как веб-сервис, принимающий POST-запрос с параметрами расчета и записывающий их в таблицу Google Sheets. Также через Apps Script API можно запрашивать конфигурационные данные. Эта часть может быть добавлена модульно, не влияя на основной функционал (например, вызывать sendToSheet(data) после получения результата, если включена интеграция).


Система контроля версий: Код проекта будет храниться в репозитории GitHub. Разработку рекомендуется вести с использованием git, что позволит отслеживать изменения, принимать вклады сообщества (open-source) и публиковать результат на GitHub Pages.


Лучшие практики разработки:
Код должен быть читаемым и документированным. Использовать понятные имена переменных, функций. В ключевых местах добавить комментарии (особенно в алгоритме расчета стоимости и загрузке моделей).


Структура проекта – разнести по папкам: например, src/ для исходников, lib/ для внешних библиотек (если подключаются локально), dist/ для сборки (если используется сборщик). Поскольку проект будет размещен на GitHub, рекомендуется включить README.md с описанием, и возможно LICENSE файл (если открытый код).


Позаботиться об оптимизации: не держать в сцене слишком много полигонов, при необходимости уменьшать уровень детализации модели (например, методами Three.js bufferGeometry simplification). Очищать объекты/геометрию при загрузке новой модели, чтобы не накапливать потребление памяти.


Безопасность: хоть приложение и фронтендовое, стоит предусмотреть проверку инъекций (если где-то выводятся данные пользователя, например имя файла – экранировать). В случае использования сторонних API (Google) – не хранить открыто чувствительные ключи в репозитории (Google API key можно ограничить по домену, либо вынести в отдельный конфигурационный файл, не публиковать его).


Поддержка браузеров и устройств
Одно из требований – кросс-браузерность и адаптивность. Приложение Step3D должно корректно работать и выглядеть во всех современных браузерах:
Десктоп: Google Chrome, Mozilla Firefox, Safari (macOS), Microsoft Edge – последних (актуальных на 2025 год) версий. Также желательно протестировать в Opera, Яндекс.Браузере и других браузерах на том же движке.


Мобильные устройства: Mobile Safari (iOS, iPhone/iPad), Chrome/Firefox на Android. Учесть, что на iOS WebGL поддерживается начиная с определенных версий (iOS 13+ вполне поддерживает). На Android – большинство современных устройств поддерживают WebGL через Chrome. Приложение должно быть протестировано на различных разрешениях экрана – от ~360px шириной (телефон) до 4K мониторов.


Адаптивный дизайн: Использовать относительные единицы и гибкую вёрстку, чтобы интерфейс автоматически подстраивался. Например, на узких экранах боковая панель превращается в верхнюю/нижнюю, текстовые метки сокращаются или скрываются, элементы выстраиваются столбцом. Шрифты – масштабируются (можно использовать vw единицы или медиа-запросы для ступенчатого изменения размера текста).


Тестирование: Провести тесты в разных средах. Особое внимание – мобильным: проверить удобство касаний (достаточный размер кнопок), работоспособность жестов поворота/ズума модели. Проверить производительность – например, на среднем смартфоне модель с ~50k треугольников должна вращаться плавно. Если обнаружатся проблемы, возможно, уменьшитьComplexity рендеринга на мобиле (например, отключить тени).


Полноэкранный режим (опционально): Можно предоставить кнопку «На весь экран» для 3D-вида, что особенно полезно на мобильных (переключает canvas в полноэкранный режим через requestFullscreen). Но убедиться, что интерфейс в этом режиме тоже доступен (например, выход из полноэкрана по кнопке "выход").


Retina/HiDPI экраны: Настроить renderer.setPixelRatio(window.devicePixelRatio) в Three.js, чтобы на дисплеях с высокой плотностью пикселей (Retina) отрисовка была четкой. Это улучшит качество изображения модели на современных смартфонах и MacBook с Retina, хотя нужно следить за производительностью (не ставить слишком высокий pixelRatio для очень тяжелых сцен).


В целом, приложение должно быть responsive и mobile-friendly, обеспечивая удобный доступ к 3D-контенту на любых устройствах.
Интеграция с Google Sheets и Google Apps Script
(Данный функционал планируется как дополнительный, не обязательный в первой версии, но архитектура должна облегчать его внедрение.)
Цели интеграции:
Хранение расчетов: сохранять результаты оценок стоимости, выполненных пользователями, в онлайн-таблице (Google Sheets) для дальнейшего анализа, ведения учета или вывода статистики. Например, каждая запись может включать: дату/время, имя загруженного файла или ID модели, рассчитанный объем, вес, цену, материал и т.д.


Загрузка конфигурации: хранить в Google Sheets настраиваемые параметры для расчетов – стоимость материалов, ставка за час, процент наценки. Это позволит менеждерам проекта обновлять тарифы (например, если изменилась цена пластика) без изменения кода приложения: достаточно поправить значения в таблице.


Способы реализации:
В Google Sheets создается необходимая таблица (или несколько). Затем на базе Google Apps Script пишется скрипт-вебслужба:


Прием данных: Скрипт предоставляет URL (виде веб-приложения, развернутого для всех с доступом по ссылке). Приложение Step3D может отправлять POST-запросы на этот URL с данными расчета (например, в формате JSON или как форма). Скрипт, получив запрос, добавляет новую строку в таблицу с переданными данными. В ответ может возвращать статус (успех/ошибка).


Выдача данных: Другой API-метод – выдача JSON с параметрами конфигурации. Приложение Step3D при загрузке может сделать GET-запрос к Apps Script, который считывает значения из определенного диапазона таблицы (например, таблица "Config" с полями "Цена_PLA_кг", "Цена_ABS_кг", "Ставка_час", "Маржа_%") и возвращает их. После этого приложение использует эти значения для расчетов. Нужно учесть кэширование/обновление: можно предусмотреть обновление параметров при каждом запуске страницы или раз в сессию.


Аутентификация и безопасность: Если таблица не публичная, доступ к Apps Script API может потребовать ключ или авторизацию OAuth. В рамках упрощения можно сделать таблицу доступной для чтения/записи по секретной ссылке (что Apps Script обеспечивает). Но лучше, чтобы URL скрипта и формат запроса были закрыты от посторонних, поэтому можно вшить простой ключ API (совпадающий между фронтендом и скриптом) либо настроить Apps Script принимать запросы только с определенного источника (например, с домена GitHub Pages приложения).


Интерфейс пользователя: В самой первой версии приложения интеграция с Google Sheets может происходить “за кадром”, без видимого изменения UI. Если же предполагается функция “сохранить результат” – тогда нужна кнопка, при нажатии которой выполняется отправка на Google (и уведомление об успехе, например "Сохранено"). Для загрузки конфигурации UI вообще не меняется – кроме, возможно, индикатора при запуске "Загрузка параметров...".


Протокол и формат: Использовать AJAX (Fetch). Формат – JSON. Например, отправлять JSON: { model:"file.stl", volume:123.4, weight:24.8, time:2.0, cost:530, material:"PLA" }. В таблице Google Sheets каждый из этих полей будет колонкой.


Расширяемость: Спроектировать код так, чтобы модуль работы с внешним API был изолирован. Например, функцию sendCalculationToSheet(data) и loadConfigFromSheet(callback). Тогда их можно будет доработать или отключить без затрагивания остальных частей. В конфигурации проекта можно иметь флаг ENABLE_GOOGLE_INTEGRATION для легкого включения/выключения этой функциональности (вдруг понадобится запускать офлайн или без сбора данных).


Преимущество такого подхода – минимум бэкэнда: Google Sheets выступает в роли базы данных, Apps Script – лёгкого сервера. Это подходит для небольшого объема данных и упрощает размещение (не нужна отдельная хостинг-платформа для сервера). Однако следует понимать ограничения: квоты Apps Script, время отклика (несколько сотен миллисекунд) – для наших задач это не критично.

Масштабируемость и будущее развитие
При разработке Step3D необходимо заложить возможности для масштабирования функциональности и добавления новых возможностей в будущем, без кардинальной переработки архитектуры. Ниже перечислены предполагаемые направления развития и меры, которые стоит предусмотреть заранее:
Поддержка новых форматов: Помимо STL и OBJ, мир 3D развивается, и появляются популярные форматы:


GLTF/GLB – современный формат от Khronos, оптимизированный для веб (компактный, сжатый, поддерживает материалы и анимации). Его поддержка позволила бы показывать более сложные сцены. Three.js имеет GLTFLoader, поэтому достаточно подключить его и добавить возможность выбора .gltf/.glb файлов.


PLY, 3DS, Collada (DAE) – их поддержка тоже есть в Three.js. Если потребуется, добавить подобный loader.


Прочее: например, поддержка архивов (zip с моделью) – можно реализовать декомпрессию на клиенте (через JS-библиотеки) и вытаскивание модели.


Предусмотреть плагинную архитектуру загрузки: сделать обобщенный интерфейс loadModel(file) внутри которого в зависимости от расширения вызывается соответствующий парсер. Это облегчит добавление новых форматов. Также учесть, что не все форматы содержат единицы измерения – возможно, потребуется аналогичный ввод габаритов для них.


Расширение ассортимента материалов: Сейчас только PLA и ABS. В будущем можно добавить другие нити (PETG, нейлон, композиты). Для этого архитектура расчета должна поддерживать список материалов. Например, хранить параметры в структуре данных (объект или таблица) и при добавлении нового материала добавлять в эту структуру и UI. Можно вместо жесткого списка PLA/ABS сделать выпадающий список, который формируется динамически на основе массива материалов (пока массив из двух элементов, но легко расширить).


Различные технологии печати: В перспективе Step3D может применяться и для других технологий (резин-печать SLA, порошковая SLS и т.д.). У них иные показатели стоимости (например, SLA – смола по объему + время, SLS – целый объем камеры, и пр.). Пока это вне объема текущего проекта, но если код будет модульным, можно в будущем добавить опцию "тип печати" (FDM/SLA/SLS) и задать для них разные формулы. То есть разделить логику расчета по типам. Поэтому сейчас стоит хранить формулы/ставки в одном месте, легко поддающемся изменению.


Масштаб пользователей и производительность: Если проект станет популярным и будет обслуживать много пользователей, важно, что он целиком работает на стороне клиента (то есть бремя вычислений на клиентских браузерах, а не на сервере). Это хорошо масштабируется – нет нагрузочного сервера. Однако, обьем моделей (файлов) может быть большим. Браузер может обрабатывать десятки мегабайт геометрии, но на очень слабых устройствах возможны лаги. Можно внедрить оптимизации: ограничивать полигонаж, просить пользователей не загружать файлы более определенного размера, или реализовать редукцию (например, Decimation mesh).


Платежные системы: Планируется подключение оплаты, чтобы пользователь мог сразу оплатить заказ на 3D-печать. Это требует:


Интеграции с платежным шлюзом (например, Stripe, PayPal, Яндекс.Касса и др.). На стороне фронтенда обычно интеграция заключается во всплывающем виджете или переадресации на оплату. Однако, прием оплаты – это критичный процесс, требующий бэкэнда (для безопасного хранения ключей, подтверждения платежа). Возможный путь – внедрение поддержка Stripe Checkout или аналогичного сервиса, где фронтенд переадресует на оплату, а обратно получает подтверждение.


В рамках Step3D, пока нет собственного сервера, можно сначала ограничиться генерацией ссылки для оплаты (например, если есть привязка к конкретному сервису печати). Но лучше закладывать возможность легко интегрировать Step3D в состав более крупного веб-приложения, где есть сервер.


UI: Добавится кнопка "Оплатить/Заказать". После расчета цены пользователь нажимает, далее либо переходит на страницу оформления заказа (где вводит адрес, контакт и т.п.), либо сразу на оплату.


Онлайновые сервисы 3D-печати: возможно, вместо собственной реализации платежей, Step3D будет интегрирован с существующими платформами (например, API 3Dhubs или локальной мастерской). Тогда кнопка "Заказать" может отправлять модель и параметры через API на сторонний сервис, а пользователь – получать ссылку на оплату там. Нужно предусмотреть возможность экспортировать модель (например, в тот же STL) и данные по API.


Подготовка к этому: отделить модуль расчета от отображения. Например, сделать так, что все данные о модели и расчете хранятся в объекте printJob, который можно легко сериализовать (в JSON) и отправить наружу. Тогда для оплаты/заказа можно этот объект передать на сервер или в другой приложение.


UI и брендирование: Если проект будет расти, возможно, появятся требования по брендированию (логотипы, цвета). Сейчас минимализм – хорошо, но нужно чтобы смена цветовой схемы или добавление логотипа не требовало переписывать весь CSS. Для этого в стилях можно использовать переменные (CSS custom properties) или хотя бы центрально определить цвета. Также, изначально проект - open-source, но если его будут использовать коммерчески, может потребоваться локализация на другие языки. Поэтому, хотя ТЗ на русском, код лучше писать с возможностью перевода (текстовые строки выносить в конфиг или ресурсы).


Дополнительные функции визуализации: Возможность просчета поддержек (supports) для модели, отображение предполагаемых поддержек на модели, расчет их влияния на стоимость; аннотации модели (например, габаритный куб, линейка для измерения расстояний). Эти функции не входят в MVP, но если код построен расширяемо (например, есть класс Viewer с методами addObject, highlight etc.), то потом можно добавлять такие возможности.


Журналы и аналитика: По мере роста приложения, может понадобиться сбор статистики использования (какие модели загружают, средняя стоимость). Для этого при интеграции с Google Analytics или Яндекс Метрикой убедиться, что события (загрузка модели, расчет произведен) можно отследить. Это больше к нефункциональным требования, но стоит отметить.


Важно, что все вышеперечисленные возможности не заложены прямо в первую реализацию, однако проект должен быть написан чисто и модульно, чтобы добавление нового функционала было локальным. Например, добавление нового формата – просто добавление нового Loader и пары строк, а не переписывание всего загрузчика; или смена формулы стоимости – правка одной функции, а не множества разбросанных мест.
Развертывание и размещение на GitHub
Так как проект будет опенсорсным и размещаемым на GitHub, необходимо подготовить инструкцию и учесть нюансы деплоя.
Структура репозитория:
В корне репозитория разместить файл README.md с описанием проекта, инструкцией по запуску и развертыванию, а также перечислением основных возможностей.


Исходный код разместить, например, в папке src/. Если используется сборщик, настроить сборку так, чтобы результирующие файлы (HTML, CSS, JS) попадали либо в dist/ папку, либо непосредственно в корень (для GitHub Pages удобен вариант, когда index.html находится в корне репо или в docs/).


Добавить файл .gitignore (исключить папки типа node_modules, dist и прочие временные).


Добавить лицензию (MIT или другую, в зависимости от решения владельцев проекта) в LICENSE файле.


Если есть сторонние библиотеки (Three.js), которые не подключаются через CDN, а хранятся локально, разместить их в папке lib/ или описать как зависимости в package.json.


Запуск локально:
Привести инструкции, как запустить приложение для разработки. Например:


Установка зависимостей: npm install (если проект использует npm).


Сборка (если нужна): npm run build.


Запуск локального сервера: npm run start (либо указать, что можно просто открыть index.html в браузере, если все ресурсы локальны).


Можно включить простой сервер разработки (например, использовать http-server npm пакет для обслуживания статических файлов) – это полезно, так как напрямую открыть HTML в браузере может мешать политика безопасности при загрузке файлов (FileReader работает, но импорт модулей JS по file:// протоколу может быть заблокирован).


Описать, что основной файл – index.html, его нужно открыть в браузере для использования приложения.


Размещение на GitHub Pages:
Предусмотреть, чтобы приложение могло быть запущено с GitHub Pages. Это значит:


Относительные пути в приложении – чтобы все ресурсы загружались корректно.


Если используется роутинг (не актуально для SPA без навигации), но у нас навигации нет.


В README описать: чтобы опубликовать, владелец форка/репозитория может включить GitHub Pages и указать папку (root или /docs). Если используем /docs – то собрать файлы в эту папку.


Опционально, настроить GitHub Actions для автоматической публикации на Pages при каждом пуше в main.


Проверка перед публикацией:
Удостовериться, что никаких секретных данных (ключей API, приватных ссылок) нет в публичном репо. Если интеграция с Google требует скрипт-ID, возможно, его придется или не публиковать, или сделать общедоступным без риска.


Размер репозитория: большие примеры моделей не включать, чтобы репо не раздулось. Если нужны примеры моделей, лучше дать ссылки на них или хранить маленькие файлы.


Документация:
Помимо README, можно подготовить Wiki с доп. информацией: описание архитектуры, как добавить новый материал или формат, и т.д. Это поможет сторонним разработчикам быстрее влиться.


Комментарии в коде: желательно документировать публичные методы (например, JSDoc комментарии), чтобы при генерации документации или просто чтении кода было понятно назначение функций.


Следуя этим рекомендациям, проект будет легко разворачиваемым и поддерживаемым. Любой разработчик сможет склонировать репозиторий, установить зависимости и запустить Step3D локально или на своем форке Pages.

### Публикация на GitHub Pages

1. Установите Node.js и клонируйте репозиторий.
2. Выполните `npm run deploy`. Скрипт опубликует содержимое папки `public/` в ветку `gh-pages` с помощью утилиты `gh-pages`.
3. В настройках репозитория GitHub выберите ветку `gh-pages` источником Pages.
4. Через несколько минут приложение будет доступно по адресу вида `https://<username>.github.io/<repository>`.
UI/UX-гайдлайны (современный минимализм)
Дизайн интерфейса Step3D должен соответствовать принципам современного минимализма – это значит, что интерфейс будет чистым, функциональным и не отвлекающим. Ниже приведены основные гайдлайны, которым следует придерживаться:
Фокус на содержании: В нашем случае главное содержание – 3D-модель и итоговая стоимость. Все остальные UI-элементы должны быть второстепенными. Минимализм требует убрать все несущественное. Каждый элемент на экране должен иметь четкое предназначение и пользу. Нет декоративных отвлекающих блоков, фоновых изображений, которые не несут смысловой нагрузки.


Много свободного пространства (whitespace): Не бояться пустого места. Поля вокруг модели, отступы между текстовыми элементами – все это создает ощущение легкости. Белый (светлый) фон и значительные отступы помогают глазу лучше фокусироваться на важных частях интерфейса. Расположение элементов должно "дышать", ничего не прижато друг к другу вплотную.


Ограниченная цветовая палитра: Рекомендуется использовать нейтральные цвета для фона и основных компонентов – белый, светло-серый, черный для текста. 1-2 акцентных цвета можно применить для выделения интерактивных элементов (например, одна яркая кнопка "Заказать печать" может быть синей или зеленой на фоне общего серо-белого тона). Акцентный цвет также можно использовать для индикации (например, выделение выбранного материала). Следует избегать пестрых раскрасок, градиентов. Цветовая схема – плоская (flat), без объемных эффектов.


Чистая типографика: Шрифт – без засечек (например, Helvetica, Arial, либо современные открытые аналоги: Roboto, Open Sans). Размер шрифта – достаточно крупный для чтения на разных устройствах (базовый 14–16px для текста, больше для заголовков/цены). Применять контрастный цвет текста – обычно темно-серый или черный текст на белом фоне для максимальной читабельности. Минимизировать использование разных размеров и начертаний – достаточно 2-3 уровня (заголовок, основной текст, мелкий вспомогательный текст).


Простые формы и элементы: Кнопки, поля ввода – оформлены в едином стиле: простые прямоугольники с легким скруглением углов (например, border-radius: 4px – небольшая скругленность для современного feel). Без теней или с очень мягкими тенями для отделения от фона. Иконки (если нужны, например, иконка загрузки файла) – использовать плоские векторные иконки (можно подключить библиотеку иконок, например Feather Icons или Font Awesome в легкой сборке). Иконки должны быть монохромными, вписываться по стилю.


Минимум текста: Тексты инструкций и сообщений – краткие и по делу. Например, вместо "Пожалуйста, выберите файл для загрузки" достаточно "Загрузите модель". Тон – дружелюбный, но лаконичный. Если требуется дополнительное пояснение, можно скрыть его под всплывающей подсказкой (tooltip) или справкой, чтобы не загромождать интерфейс.


Интуитивность: Пользователь без чтения документации должен понять, как воспользоваться приложением. Поэтому UI-элементы должны быть ожидаемыми: значок загрузки (иконка папки со стрелкой) на кнопке, понятные подписи ("Материал:", "Размер, мм:", "Стоимость:"). Если что-то не очевидно – добавить подсказку при наведении. Но постараться сделать так, чтобы все было очевидно и так.


Анимации и реакции: Минимализм не означает полное отсутствие анимаций, но они должны быть ненавязчивыми и функциональными. Например, плавное появление модели при загрузке (фейд-ин), подсветка кнопки при наведении, небольшое изменение цвета/тени при нажатии – эти микро-анимации делают интерфейс отзывчивым. Время анимации короткое (200-300 мс), без задержек – чтобы не замедлять работу пользователя.


Адаптивность = удобство: В UX-гайдах для мобильных устройств – большие тач-таргеты (минимум ~40px высотой кнопки), учет области экрана (на мобильном основные элементы – в центре или внизу, чтобы легче дотянуться пальцем). На десктопе – можно располагать элементы сверху, где взгляд сначала падает. Минималистичный дизайн упрощает адаптивность, так как элементов мало и их легче переставить.


Повышенная производительность: Удаление всего лишнего положительно сказывается на производительности приложения. Отсутствие тяжелой графики, избыточных скриптов и плагинов поможет странице загружаться быстрее и работать плавно даже на не самых новых устройствах. Это соответствует принципам UX: быстрое отклик – часть хорошего пользовательского опыта.


Консистентность: Все элементы интерфейса оформлены единообразно. Если выбрана определенная стилистика кнопок – все кнопки ей соответствуют. Если цвет акцента – применять его для сходных вещей (например, синий для активных элементов). Следовать принципу: однотипным элементам – однотипный вид и поведение.


Тестирование удобства: После реализации дизайна имеет смысл провести небольшое UX-тестирование: дать нескольким пользователям попробовать загрузить модель и понять стоимость. Если они где-то запнулись или искали кнопку – внести коррективы в интерфейс (например, сделать кнопку более заметной, добавить подпись).


Следование этим гайдлайнам обеспечит современный и привлекательный вид приложения. Минималистичный интерфейс позволит пользователям сосредоточиться на своей 3D-модели и полученной информации о стоимости, не отвлекаясь на сложности настроек. Таким образом, Step3D будет восприниматься как профессиональный, но простой инструмент, с которым приятно работать.

## Прогресс и план

- [x] Загрузка STL/OBJ через поле выбора и Drag & Drop
- [x] Отображение модели с вращением и масштабированием
- [x] Автоматический расчёт стоимости печати
- [x] Минималистичный интерфейс
- [x] Выбор материала (PLA/ABS) в UI
- [x] Изменение масштаба/габаритов модели пользователем
- [x] Обработка ошибок при загрузке (размер, формат)
- [x] Инструкция по развертыванию на GitHub Pages
- [x] Интеграция с Google Sheets для хранения параметров
- [ ] Подключение платёжных систем или сервиса заказа
